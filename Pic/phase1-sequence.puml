@startuml
title 阶段1前后对比时序图（脚本化 -> 引擎化）

skinparam shadowing false
skinparam ArrowColor #4A4A4A
skinparam DefaultFontName Microsoft YaHei
autonumber

actor "调用方\n(Go/Wails/CLI/CI)" as Caller

== Before（改造前：脚本模式） ==
participant "app.py\n脚本入口" as LegacyApp
participant "训练逻辑\n(耦合在入口中)" as LegacyLogic
participant "print/traceback\n非结构化输出" as LegacyOut

Caller -> LegacyApp : 传参(命令行/全局变量)
LegacyApp -> LegacyLogic : 直接执行训练/检测
LegacyLogic -> LegacyOut : print() / traceback
LegacyOut --> Caller : 文本输出\n(难解析、难编排)

== After Stage 1（改造后：Python Engine） ==
participant "engine_main.py\n统一CLI入口" as Main
participant "engine_protocol.py\n协议校验/错误码" as Protocol
participant "engine_service.py\naction路由" as Service
participant "engine_core.py\n动作执行封装" as Core
participant "training_core.py\n核心算法" as Algo
participant "engine_logging.py\n结构化日志(stderr)" as Log

Caller -> Main : Request JSON\n(task_id/action/payload)
Main -> Protocol : 解析与校验请求
Protocol --> Main : 规范化输入 or error_code
Main -> Service : dispatch(action)
Service -> Core : run(action,payload)
Core -> Algo : train()/health()
Algo --> Core : 结果与产物路径
Core --> Service : action result
Service --> Main : response payload
Main -> Log : 写JSON日志(stderr)
Main --> Caller : Response JSON\n(status/result/error_code/duration_ms)

alt 非法输入
  Caller -> Main : 非法JSON或缺失字段
  Main -> Protocol : 校验失败
  Main --> Caller : error_code=INVALID_JSON/INVALID_INPUT
end

note over Caller, Main
阶段1可见收益：
1) 输出可机读（统一JSON协议）
2) 错误可定位（统一错误码）
3) 调用可编排（便于Go后端托管任务）
4) 行为可测试（确定性与边界可覆盖）
end note

@enduml
