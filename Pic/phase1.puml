@startuml
title 阶段1总结：Python内核从脚本到可调用引擎

skinparam shadowing false
skinparam ArrowColor #4A4A4A
skinparam componentStyle rectangle
skinparam packageStyle rectangle
skinparam DefaultFontName Microsoft YaHei

actor "调用方\n(Go/Wails/CLI/CI)" as Caller

package "阶段1产物总览（Engine化）" #EEF6FF {
  package "入口与协议层" #F8FBFF {
    component "engine_main.py\n统一CLI入口\n读取 input.json/stdin\n输出 output.json/stdout" as Main
    component "engine_protocol.py\nRequest/Response模型\n统一错误码" as Protocol
    component "engine_logging.py\n结构化日志(JSON)\nstderr与stdout分离" as Logging
  }

  package "服务与算法层" #F5FFF8 {
    component "engine_service.py\naction路由与调度" as Service
    component "engine_core.py\n训练/检测动作封装" as EngineCore
    component "src/training_core.py\n核心算法逻辑" as TrainingCore
    component "src/utils.py\n兼容导出(不破坏app.py)" as Utils
  }

  package "质量保障" #FFF9F2 {
    component "tests/python_engine/\n协议、异常、确定性测试" as Tests
    component "pytest + coverage\n核心算法覆盖率 >= 80%" as Coverage
  }
}

Caller --> Main : 提交 task_id/action/payload
Main --> Protocol : 校验请求/构造响应
Main --> Service : 分发 action
Service --> EngineCore : 执行 train/health 等动作
EngineCore --> TrainingCore : 调用核心算法
TrainingCore --> Utils : 复用兼容能力
Main --> Logging : 写结构化日志

Tests --> Main : 覆盖CLI与协议错误路径
Tests --> TrainingCore : 覆盖算法稳定性与边界
Coverage --> Tests

note right of Main
阶段1关键目标已落地：
1) 脚本逻辑分层：算法层 vs CLI层
2) 输入输出协议：input.json / output.json
3) 错误码统一：异常可读、可定位
4) 结果可复现：同一输入多次输出一致
end note

note bottom of Service
对阶段2的价值：
Go后端可稳定调用Python引擎，
前端不再直连算法脚本。
end note

@enduml
